# 一.sublime

## 1.sublime介绍

Sublime是一个代码编辑器，可以编写HTML、php、js、css等文件。

## 2.sublime优点

1. 跨平台
2. 扩展性强
3. 体积小，运行速度快
4. 支持编译功能，可以在控制台查看输出
5. 支持大量插件

## 3.sublime下载

下载地址：https://www.sublimetext.com/3

## 4.sublime破解码

http://blog.s ina.com.cn/s/blog_68e267e10102v76h.html

## 5.sublime插件安装

使用package control组件安装

### 1）package control介绍

package control是sublime软件的插件包管理器，通过该组件，我们可以很方便的管理我们插件（浏览，安装，卸载）

### 2）安装package control

#### 1.检查是否安了某个插件

ctrl+shift+p在命令板中输入pc

#### 2.在命令板中输入install 并点击包下载 等待后直接输入包名

### 3）需要安装的插件

1. ChineseLocalizations（汉化插件）
2. ConvertToUTF8（自动把编码方式改为utf-8）
3. Emmet（快速编写css，html）
4. IMESupport（光标跟随）
5. SublimeCodeIntel（代码提示）
6. SidebarEnhancements（让侧边栏功能更丰富）

# 二.浏览器

## 1.浏览器内核

浏览器的内核可以分成两部分：渲染引擎、js引擎

### 1）渲染引擎

负责取得网页的内容（html，xml，图像等）、整理讯息（css等）以及计算网页的显示方式，然后会输出至显示器或打印机

### 2）js引擎

解析JavaScript，执行JavaScript语言来实现网页的动态效果

### 3）内核

1.Trident（IE内核）

国内很多的双核浏览器的其中一个就是他，美其名曰‘兼容模式’

代表：IE、遨游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等

2.Gecko（firefox）

特点：代码公开，可开发程度很高

缺点：打开速度慢，升级频繁

代表：火狐浏览器

3.webkit（Safari）

代表：遨游浏览器3、apple Safari、Symbian手机浏览器、安卓默认浏览器

4.Chromium/Blink（chrome）

代表：谷歌浏览器

Blink是Webkit的分支

5.presto（opera）

代表：opera

以前用的是presto内核，但是现在用的是Blink内核

# 三.web标准

## 1.好处

1. 让Web的发展前景更广阔
2. 内容能被更广泛的设备访问
3. 更容易被搜索引擎搜索
4. 降低网站流量费用
5. 使网站更易于维护
6. 提高页面浏览速度

## 2.W3C标准

### 1）结构标准

结构用于对页面元素进行整理和分类，主要包括XML和XHTML

### 2）样式标准

表现用于设置网页元素的版式、颜色、大小等外观样式，主要指CSS

### 3）行为标准

行为是指网页模型的定义以及交互的编写，主要包括DOM和ECMAScript

# 四.html常用标签

## 1.文档类型（<!DOCTYPE>）

告诉我们现在使用的是哪个html版本（html5）

## 2.字符集（< meta charset='UTF-8' >）

|  名称  |                             作用                             |
| :----: | :----------------------------------------------------------: |
| UTF-8  | 目前最常用的字符集编码方式，是包含全世界所有国家需要用到的字符 |
| gb2312 |                   简体中文，包含6763个汉字                   |
|  BIG5  |                     繁体中文，港澳台等用                     |
|  GBK   |   gb2312的扩展，包含全部的中文字符，加入了对繁体中文的支持   |

## 3.标签

### 1）单标签

|     标签 |                             名字                             |
| -------: | :----------------------------------------------------------: |
| < hr / > |                          水平线标签                          |
|  < br /> |                           换行标签                           |
| < img /> |                           图片标签                           |
| < base/> | 页面跳转的方式（在head中写，属性target=_blank,_blank是新窗口打开，_self是在当前窗口打开） |

### 2）文本格式化标签

|        标签         |    名字    |
| :-----------------: | :--------: |
|      < b>< /b>      |  加粗标签  |
| < strong>< /strong> |  加粗标签  |
|      < i>< /i>      |  倾斜标签  |
|     < em>< /em>     |  倾斜标签  |
|      < s>< /s>      | 删除线文字 |
|    < del>< /del>    | 删除线文字 |
|      < u>< /u>      | 下划线文字 |
|    < ins>< /ins>    | 下划线文字 |

### 3）锚点定位

1. 目录用a标签包裹，属性href为‘#’+id
2. 给定位的地方加入相对应的id

### 4）特殊字符标签

| 特殊字符 |   描述   |   代码    |
| :------: | :------: | :-------: |
|          |  空格符  |  &nbsp ;  |
|   &lt;   |  小于号  |   &lt ;   |
|   &gt;   |  大于号  |   &gt ;   |
|  &amp;   |   和号   |  &amp ;   |
|  &yen;   |  人民币  |  &yen ;   |
|  &copy;  |   版权   |  &copy ;  |
|  &reg;   | 注册商标 |  &reg ;   |
|  &deg;   |  摄氏度  |  &deg ;   |
| &plusmn; |  正负号  | &plusmn ; |
| &times;  |   乘号   | &times ;  |
| &divide; |   除号   | &divide ; |
|  &sup2;  |   平方   |  &sup2 ;  |
|  &sup3;  |   立方   |  &sup3 ;  |



## 4.语义化标签

### 1）优点

1. 方便代码的阅读和维护
2. 让浏览器或者网络爬虫可以很好的解析，从而更好的分析其中的内容
3. 具有更好的搜索引擎优化

## 5.列表

### 1）无序列表

&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;

### 2）有序列表

&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;

### 3）自定义列表

&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/ul&gt;

# 五.表格

## 1.表格的属性

|     属性名      |                   含义                   |     常用属性值      |
| :-------------: | :--------------------------------------: | :-----------------: |
|     border      |              设置表格的边框              |       像素值        |
|   cellspacing   |   设置单元格与单元格边框之间的空白间距   |      默认2像素      |
|   cellpadding   | 设置单元格内容与单元格边框之间的空白间距 |      默认1像素      |
|      width      |                 表格的宽                 |       像素值        |
|     height      |                 表格的高                 |       像素值        |
|      align      |       设置表格在网页中水平对齐方式       | left、center、right |
| border-collapse |              边框合并在一起              |      collapse       |

## 2.表格结构

用&lt;thead&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;对表格的结构进行划分

|              名字               |   代码   |
| :-----------------------------: | :------: |
|   &lt;thead&gt;&lt;/thead&gt;   |   表头   |
|   &lt;tbody&gt;&lt;/tbody&gt;   |  表格体  |
| &lt;caption&gt;&lt;/caption&gt; | 表格标题 |

## 3.合并单元格

|   名字   |  代码   |
| :------: | :-----: |
| 跨列合并 | colspan |
| 跨行合并 | rowspan |

# 六.html5

## 1.常用新标签

|   代码   |                        含义                        |
| :------: | :------------------------------------------------: |
|  header  |                  文档的页眉  头部                  |
|   nav    |                    导航链接部分                    |
|  footer  |                  文档的页脚  底部                  |
| article  |                        文章                        |
| section  |                     文档中的节                     |
|  aside   |                        侧边                        |
| datalist |        标签定义选项列表（和input搭配使用）         |
| fieldset | 可将表单内的相关元素分组，打包（和legend搭配使用） |

## 2.input 

### 1）type新属性

|   类型   |     含义     |
| :------: | :----------: |
|  email   |   邮箱格式   |
|   tel    | 手机号码格式 |
|   url    |   url格式    |
|  number  |   数字格式   |
|  search  |    搜索框    |
|  range   | 自由拖动滑块 |
|   time   |   小时分钟   |
|   date   |    年月日    |
| datetime |     时间     |
|  month   |     月年     |
|   week   |    星期年    |
|  color   |     颜色     |

### 2）新属性

|     属性     |       含义       |
| :----------: | :--------------: |
| placeholder  |      占位符      |
|  autofocus   |   自动获取焦点   |
|   multiple   |    多文件上传    |
| autocomplete |     自动完成     |
|   required   |      必填项      |
|  accesskey   | 激活元素的快捷键 |

## 3.多媒体标签

| 标签  |      含义      |
| :---: | :------------: |
| embed | 定义嵌入的内容 |
| audio |    播放音频    |
| video |    播放视频    |

# 七.css

## 1.字体

|  字体名称   |     英文名      |     unicode编码      |
| :---------: | :-------------: | :------------------: |
|    宋体     |     SimSun      |      \5B8B\4F53      |
|   新宋体    |     NSimSun     |   \65B0\5B8B\4F53    |
|    黑体     |     SimHei      |      \9ED1\4F53      |
|  微软雅黑   | Microsoft YaHei | \5FAE\8F6F\96C5\9ED1 |
| 楷体_GB2312 |  KaiTi_GB2312   |  \6977\4F53_GB2312   |
|    隶书     |      LiSu       |      \96B6\4E66      |
|    幼园     |     YouYuan     |      \5E7C\5706      |
|  华文细黑   |     STXihei     | \534E\6587\7EC6\9ED1 |
|   细明体    |     MingLiU     |   \7EC6\660E\4F53    |
|  新细明体   |    PMingLiU     | \65B0\7EC6\660E\4F53 |

## 2.链接伪类选择器

a标签的有link，visited，hover，active四个伪类选择器

## 3.结构（位置）伪类选择器

|        代码        |                   含义                   |
| :----------------: | :--------------------------------------: |
|    :first-child    |           父元素的第一个子元素           |
|    :last-child     |          父元素的最后一个子元素          |
|   :nth-child(n)    | 父元素的第n个子元素（even偶数，odd奇数） |
| :nth-last-child(n) |          从最后一个子节点往上数          |

## 4.目标选择器

target，当前选中的元素样式，用于锚点样式修改

## 5.三大特性

1）层叠性

后面的样式覆盖掉前面的样式

2）继承性

子标签会继承父标签有关文字的样式

3）特殊性

|   元素    |  权重   |
| :-------: | :-----: |
| 元素标签  | 0,0,0,1 |
| 类、伪类  | 0,0,1,0 |
|    id     | 0,1,0,0 |
| 行内样式  | 1,0,0,0 |
| important |  无穷   |
|   继承    |    0    |

## 6.a标签

text-decoration:none   取消下划线

## 7.鼠标样式（cursor）

|   值    | 效果 |
| :-----: | :--: |
| default | 小白 |
| pointer | 小手 |
|  move   | 移动 |
|  text   | 文本 |

## 8.轮廓（outline）

input选中后的外边框，一般是要把他取消的

## 9.文本域防止拖拽（resize）

textarea防止用户拖拽

## 10.文字对齐方式（vertical-align）

只对行内元素或者行内块元素起作用，主要用于图片和表单与文字的对齐方式

|    值    | 含义 |
| :------: | :--: |
|   top    | 顶线 |
|  middle  | 中线 |
| baseline | 基线 |
|  bottom  | 底线 |

## 11.去除图片底部缝隙

1. 将图片转为块级元素（display:block）
2. vertical-align:middle或者top

## 12.英文文字换行（word-break）

1. break-all：允许拆开单词
2. keep-all：保持单词的完整性

## 13.汉字文字换行（white-space）

1. normal：换行显示
2. nowrap：在一行内显示

## 14.文字溢出（text-overflow）

1. clip：简单裁剪
2. ellipsis：省略标记

## 15.字体图标

1. 将图片转换成图标（转换网址：https://icomoon.io/     https://iconfont.cn）

2. 下载

3. 将压缩包中的fonts文件放在项目下

4. 在style下引入下面代码：

   ```css
   //声明字体
   @font-face{
       font-family:'icomoon';##可以修改，但下面使用的时候要与其对应
       src:url('fonts/icomoon.eot?7kkc2');
       src:url('fonts/icomoon.eot?7kkc2#iefix') format('embedded-opentype'),
           url('fonts/icomoon.ttf?7kkyc2')format('truetype'),
           url('fonts/icomoon.woff?7kkyc2')format('woff'),
           url('fonts/icomoon.svg?7kkyc2#icomoon')format('svg');
       font-weight:normal;
       font-style:normal;
   }
   ```

5. 使用如下：

   ```css
   span{
       font-family:'icomoon';#和上面的名称对应
   }
   或
   div::before{
       font-family:'icomoon';#和上面的名称对应
       content:"\demo中的代号"
   }
   ```

   然后打开压缩包下的demo然后复制方块应用即可

6. 追加新图标，找网页中导入压缩包中的selection.json

## 16.transform  3D效果

transform-style:preserve-3d （让父盒子里面的子盒子以3d效果显示）

pespective视距，给父元素添加

transform:translate3d(x,y,z)

反面不显示

backface-visibility:hidden

## 17.动画(animation)

animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反向

动画名称：自定义

动画时间：  s

运动曲线：默认ease，linear（匀速）

何时开始：0s

播放次数：默认1，infinite无限循环

是否反向：默认normal（正常方向），reverse（反方向），alternate（先正常运行再反向运行，并持续交替进行），alternate-reverse（先反方向再正常方向，并持续交替进行）

定义动画：@keyframes name{

}

animation-play-state：paused（暂停动画）

## 18.flex布局

父级盒子添加display:flex

子盒子添加flex:份数，order:盒子排列顺序，数值越小越靠前

父级盒子属性：flex-direction:row/column(横竖排列)

​							flex-direction:row-reverse/column-reverse(横竖排列反转)

​							justify-content:flex-start（头对齐）/flex-end（尾对齐）/center（居中对齐）/space-between（均匀分布）/space-around（均匀分布左右有缝隙）

​							align-items:flex-start（上对齐）/flex-end（下对齐）/center（垂直居中对齐）/stretch（自适应父元素的高度）

​							flex-wrap:nowrap（不换行）/wrap（换行）/wrap-reverse（翻转）

​							align-content:必须为父元素先添加flex-flow:row wrap

​							stretch（拉伸以适应容器），center（位于容器中心），flex-start（位于容器开头），flex-end（位于容器结尾），space-between（各行间有留白），space-around（上下也有留白）

## 19.浏览器前缀

| 浏览器前缀 | 浏览器                               |
| :--------: | ------------------------------------ |
|  -webkit-  | Google Chrome,Safari,Android Browser |
|   -moz-    | Firefox                              |
|    -O-     | Opera                                |
|    -ms-    | Internet Explorer,Edge               |
|  -khtml-   | Konqueror                            |

## 20.背景渐变

background:linear-gradient(渐变的起始位置，起始颜色，结束颜色)

background:linear-gradient(渐变的起始位置，颜色  0%，颜色 50%，颜色 100%)

出现浏览器兼容问题，添加前缀即可

## 21.less

```css
npm install less less-loader --save-dev
把less-loader的版本改为5.0.0

#less的知识点
##1.定义变量
@tabBar-red-style:#f00
#tabBar{
    background:@tabBar-red-style
}
@message: "this is a string";
@text: 'message';
content: @@text;
在content这个属性后面就是this is a string这个内容
##2.混合
.col-row-center{
    dispaly:flex;
    align-items:center;
    justify-content:center;
}
.message{
    .col-row-center
}
//等同于
.message{
    dispaly:flex;
    align-items:center;
    justify-content:center;
}
##3.带参数
.border-radius (@radius:10px) {
  border-radius: @radius;
  -moz-border-radius: @radius;
  -webkit-border-radius: @radius;
}
#tabBar{
  .border-radius(4px);//使用时可以在括号内写入想要的值
}
.card{
  .border-radius(6px);  
}
##4.@arguments大量传参，节省操作
.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {
  box-shadow: @arguments;
  -moz-box-shadow: @arguments;
  -webkit-box-shadow: @arguments;
}
.box-shadow(2px, 5px);
##5.模式匹配
//让.mixin根据不同的@switch值而表现各异
.mixin (dark, @color) {
  color: darken(@color, 10%);
}
.mixin (light, @color) {
  color: lighten(@color, 10%);
}
.mixin (@_, @color) {
  display: block;
}
 
//运行
@switch: light;
 
.class {
  .mixin(@switch, #888);
}
##6.引导表达式
//when关键字用以定义一个导引序列(此例只有一个导引)
.mixin (@a) when (lightness(@a) >= 50%) {
  background-color: black;
}
.mixin (@a) when (lightness(@a) < 50%) {
  background-color: white;
}
.mixin (@a) {
  color: @a;
}
 
//运行
.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }
##7.运算
（1）任何数字、颜色或者变量都可以参与运算
@base: 5%;
@filler: @base * 2;
@other: @base + @filler;
 
color: #888 / 4;
background-color: @base-color + #111;
height: 100% / 2 + @filler;
（2）less运算能够分辨出颜色和单位
@var: 1px + 5;  //less会输出6px
 
//括号也同样允许使用
width: (@var + 5) * 2;
 
//可以在复合属性中进行运算
border: (@width * 2) solid black;
##8.字符串插值
@base-url: "http://assets.fnord.com";
background-image: url("@{base-url}/images/bg.png");
```



# 八.盒模型

## 1.border

|  代码  |  作用  |
| :----: | :----: |
| solid  |  实线  |
| dashed |  虚线  |
| dotted |  点线  |
| double | 双实线 |

## 2.border-radius

border-radius:四个角

border-radius:左上右下 + 左下右上

border-radius:左上  +  左下右上  +  右下

border-radius:左上  +  右上  +  右下  +  左下

## 3.外边距合并（兄弟元素）

垂直的块级盒子，外边距会出现合并的问题。避免即可

## 4.外边距塌陷问题（父子元素）

子元素的margin-top失效

解决办法：给父元素加个边框或者加个padding或者overflow：hidden（触发bfc）

## 5.盒子阴影（box-shadow）

|    值    |    描述    |
| :------: | :--------: |
| h-shadow |  水平阴影  |
| v-shadow |  垂直阴影  |
|   blur   |  模糊距离  |
|  spread  | 阴影的尺寸 |
|  color   | 阴影的颜色 |
|  inset   |  内外阴影  |



## 6.float

浮动后元素具有行内块特性，有宽度和高度，盒子大小由内容决定

## 7.清除浮动

为了解决父级元素因为子集元素浮动引起内部高度为0的问题

1. 父元素下添加一個空元素並添加样式clear:both

2. 父元素添加样式overflow:hidden

3. 父元素添加伪元素

   .clearfix:after{

   content:".";

   display:block;

   height:0;

   visibility:hidden;

   clear:both

   }

   .clearfix{

   *zoom:1

   }

4. 父元素添加双伪元素

   .clearfix:before,.clearfix:after{

   content:"";

   display:table

   }

   .clearfix:after{

   clear:both

   }

   .clearfix{

   *zoom:1

   }

## 8.定位

position：static清除定位

position：relative 相对定位，以自己左上角为基准，不脱离标准流

position：absolute绝对定位，以有定位的父元素为基准，脱离标准流

## 9.BFC（块级格式化上下文）

是一块独立渲染的区域

内部元素不会影响外面的元素

display为block，list-item，table的元素会产生BFC

float属性不为none，position为absolute或fixed，display为inline-block，table-cell，table-caption，inline-flex，overflow不为visible即可触发BFC

BFC布局特性：

1. 盒子从顶端垂直的一个一个排列
2. 两个相邻的盒子的margin会发生重叠
3. 每一个盒子的左外边缘会触碰到容器的左边缘
4. BFC区域不会与浮动的盒子产生交集，而是紧贴浮动边缘
5. 计算BFC高度时，自然也会检测浮动盒子的高度

用途：1.清除浮动

​			2.解决外边距合并问题

# 九.js

## 1.构造函数/原型对象/对象-->原型链

构造函数的名字第一个字母大写

构造函数是构造对象的函数

工具中使用静态成员例如Math中的PI，有很多个实例的时候使用实例成员即构造函数中的实例成员

每个构造函数都有一个原型对象，构造函数创建对象，对象通过proto指向原型对象，原型对象通过constructor指向构造函数，构造函数通过prototype指向原型对象，Object构造函数生成原型对象，原型对象的原型对象是object，object的原型对象是null

## 2.构造函数的继承

```js
//借用构造函数
function Person(name,age,sex){
    this.name=name
    this.age=age
    this.sex=sex
}
function Student(name,age,sex,score){
    Person.call(this,name,age,sex)//call用来改变this指向
    this.score=score
}

```

# 十.TypeScript

## 1.基础类型

基础类型有：数字、字符串、结构体、布尔值

### 1）.布尔值

```js
let isDone: boolean = false;
```

### 2）.数字

```js
let decLiteral: number = 6;//十進制
let hexLiteral: number = 0xf00d;//十六進制
let binaryLiteral: number = 0b1010;//二進制
let octalLiteral: number = 0o744;//八進制

```

### 3）.字符串

```js
let name: string = "bob";
name = "smith";
//模板字符串
let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.
I'll be ${ age + 1 } years old next month.`;
```

### 4）.數組

```js
//方式一
let list:number[]=[1,2,3]
//方式二（使用數組汎型）
let list:Array<number>=[1,2,3]
```

### 5）.元組

```js
//已知元素數量和元素類型的數組，且各元素的類型不相同
let x: [string, number];
x = ['hello', 10]; // OK
x = [10, 'hello']; // Error
//当访问一个越界的元素，会使用联合类型替代
x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型
console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString
x[6] = true; // Error, 布尔不是(string | number)类型
```

### 6）.枚舉

```js
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
//可以設置枚舉類型的初始索引
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
//可以手動設置全部索引
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
```

### 7）.Any

我们不希望类型检查器对值进行检查，直接让它们通过编译阶段的检查

```js
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; 
let list: any[] = [1, true, "free"];
list[1] = 100;
//以上操作都是可以的
```

### 8）.void

表示麽有任何類型

```js
function warnUser(): void {
    console.log("This is my warning message");
}
```

### 9）.Null和Undefined

null和undefined都有自己的類型分別叫做null和undefined，默认情况下`null`和`undefined`是所有类型的子类型

```js
let u: undefined = undefined;
let n: null = null;
```

### 10）.never

`never`类型表示的是那些永不存在的值的类型。 例如， `never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never`类型，当它们被永不为真的类型保护所约束时。

`never`类型是任何类型的子类型，也可以赋值给任何类型；然而，*没有*类型是`never`的子类型或可以赋值给`never`类型（除了`never`本身之外）。 即使 `any`也不可以赋值给`never`。

下面是一些返回`never`类型的函数：

```js
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
```

### 11）.Object

`object`表示非原始类型，也就是除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型。

```js
declare function create(o: object | null): void;
create({ prop: 0 }); // OK
create(null); // OK
create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

### 12）.類型斷言

```js
//類型斷言的兩種方式
//尖括號語法
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
//as語法
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```

## 2.變量聲明

### 1.聲明變量的方式

```js
//var
可重複聲明
全局有效
//let
不可重複聲明
域内有效
//const
類似let
值不可修改
const numLivesForCat = 9;
const kitty = {
    name: "Aurora",
    numLives: numLivesForCat,
}
// Error
kitty = {
    name: "Danielle",
    numLives: numLivesForCat
};
// all "okay"
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;
```

### 2.解構

```js
//結構數組
let input = [1, 2];
let [first, second] = input;
//相當於
first = input[0];
second = input[1];
//swap
[first, second] = [second, first];
//作用于函数
function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}
f(input);
//剩余变量
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
//對象結構
let o = {
    a: "foo",
    b: 12,
    c: "bar"
};
let { a, b } = o;
或
({ a, b } = { a: "baz", b: 101 });
//對象的剩餘變量
let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
//屬性重命名
let { a: newName1, b: newName2 } = o;
可以理解爲将 a: newName1 读做 "a 作为 newName1"
//對象指示類型
let {a, b}: {a: string, b: number} = o;
//默認值
function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}
即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。
//函數聲明
type C = { a: string, b?: number }
function f({ a, b }: C): void {
}
```

## 3.接口

```js
接口的作用就是为类型命名和为你的代码或第三方代码定义契约。
//接口初探
function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
//接口使用
interface LabelledValue {
  label: string;
}
function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}
let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
//可選屬性（option bags）
interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
let mySquare = createSquare({color: "black"});
带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。
可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示
//只讀屬性
一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性
interface Point {
    readonly x: number;
    readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
//額外的屬性檢查
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
//函數類型
interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}
形參的名字可以與接口的不同
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result > -1;
}
//可索引類型
interface StringArray {
  [index: number]: string;
}
let myArray: StringArray;
myArray = ["Bob", "Fred"];
let myStr: string = myArray[0];
```

## 4.类

```js
//一個類的例子
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}
let greeter = new Greeter("world");
//繼承
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}
class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}
const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
//重写父元素的方法
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}
let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");
sam.move();
tom.move(34);
派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法
```

# 十一.react、umi、dva

umi是路由配置、dva是数据流方案。

umi和dva都是基于react的框架、umi以路由为主、dva主要管理数据流

## 1.dva

dva是什么？dva 是体验技术部开发的 React 应用框架，将上面三个 React 工具库包装在一起，简化了 API，让开发 React 应用更加方便和快捷。

dva = React-Router + Redux + Redux-saga

### 1）数据流图

![image-20211110104149992](C:\Users\MECHREVO\AppData\Roaming\Typora\typora-user-images\image-20211110104149992.png)

### 2）核心概念

- State：一个对象，保存整个应用状态
- View：React 组件构成的视图层
- Action：一个对象，描述事件
- connect 方法：一个函数，绑定 State 到 View
- dispatch 方法：一个函数，发送 Action 到 State3

State 是储存数据的地方，收到 Action 以后，会更新数据。

View 就是 React 组件构成的 UI 层，从 State 取数据后，渲染成 HTML 代码。只要 State 有变化，View 就会自动更新。

### 3）Action、connect、dispatch

```js
//Action 是用来描述 UI 层事件的一个对象。
{
  type: 'click-submit-button',
  payload: this.form.data
}
//connect 是一个函数，绑定 State 到 View。
import { connect } from 'dva';
function mapStateToProps(state) {
  return { todos: state.todos };
}
connect(mapStateToProps)(App);
//dispatch 是一个函数方法，用来将 Action 发送给 State。
dispatch({
  type: 'click-submit-button',
  payload: this.form.data
})
//dispatch 方法从哪里来？被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。
```

### 4）dva应用的最简结构（带 model)

```js
// 创建应用
const app = dva();

// 注册 Model
app.model({
  namespace: 'count',
  state: 0,
  reducers: {
    add(state) { return state + 1 },
  },
  effects: {
    *addAfter1Second(action, { call, put }) {
      yield call(delay, 1000);
      yield put({ type: 'add' });
    },
  },
});

// 注册视图
app.router(() => <ConnectedApp />);

// 启动应用
app.start('#root');
```

数据流图1：

![image-20211110113556721](C:\Users\MECHREVO\AppData\Roaming\Typora\typora-user-images\image-20211110113556721.png)

数据流图2：

![image-20211110113621771](C:\Users\MECHREVO\AppData\Roaming\Typora\typora-user-images\image-20211110113621771.png)

### 5）app.model

dva 提供 app.model 这个对象，所有的应用逻辑都定义在它上面。

```js
{
  namespace: 'count',//当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成
  state: 0,//该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出
  reducers: {
    add(state) { return state + 1 },
  },//Action 处理器，处理同步动作，用来算出最新的 State
  effects: {
    *addAfter1Second(action, { call, put }) {
      yield call(delay, 1000);//call执行异步函数
      yield put({ type: 'add' });//put发出一个action，类似dispatch
    },
  },//Action 处理器，处理异步动作
}
```

# 十二.webpack

## 1.概念

webpack是一个用于现代javascript应用程序的**静态模块打包工具**。当webpack处理应用程序时，他会在内部从一个或多个入口点构建一个**依赖图**，然后将你的项目中所需的每一个模块组合成一个或者多个**bundles**，它们均为静态资源，用于展示你的内容。

### 1.入口

入口是指webpack应该使用哪个模块来作为构建其内部**依赖图**的开始，进入入口起点后，webpack会找出有哪些模块和库是入口起点所依赖的

```js
//webpack.config.js（默认是以./src/index.js为入口）
简写语法
entry: string | [string]
//简单写法
module.exports={
  entry:'',//入口文件的地址  
};
//单个入口写法
module.exports = {
  entry: {
    main: '',//入口文件的地址 
  },
};
//一次注入多个依赖文件并将他们的依赖关系绘制在一个'chunk'中
module.exports = {
  entry: ['./src/file_1.js', './src/file_2.js'],
  output: {
    filename: 'bundle.js',
  },
};
--------------------------------------------------------
对象语法
entry: { <entryChunkName> string | [string] } | {}
//对象语法是定义入口最可扩展的方式
module.exports = {
  entry: {
    app: './src/app.js',
    adminApp: './src/adminApp.js',
  },
};
/*
描述入口的对象：
dependOn：当前入口所依赖的入口，依赖的入口需要在当前入口加载前加载
filename：输出文件名称
import：启动时需加载的模块
library：为当前entry构建一个library
runtime：运行时chunk名字，如果设置了，就会创建一个新的运行时chunk
publicPath：入口的输出文件在浏览器中被引用时，为它们指定一个公共URL地址
*/
module.exports = {
  entry: {
    a2: 'dependingfile.js',
    b2: {
      dependOn: 'a2',
      import: './src/app.js',
    },
  },
};
//runtime 和 dependOn 不应在同一个入口上同时使用，runtime 不能指向已存在的入口名称，dependOn 不能是循环引用

```

### 2.输出

输出是指webpack在哪里输出所创建的bundle，以及这些文件的命名

```js
//webpack.config.js（主要输出文件默认放在./dist/main.js、其他文件默认放在./dist文件夹中）
const path = require('path');
module.exports = {
  entry: '',//入口地址
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '',//打包后的文件名
  },
}
//即使可以存在多个 entry 起点，但只能指定一个 output 配置
//多个入口起点，需要用占位符来确保每个文件具有唯一的名称
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js',
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist',
  },
};// 写入到硬盘：./dist/app.js, ./dist/search.js
//高级进阶
module.exports = {
  output: {
    path: '/home/proj/cdn/assets/[fullhash]',
    publicPath: 'https://cdn.example.com/assets/[fullhash]/',
  },
};
如果在编译时，不知道最终输出文件的 publicPath 是什么地址，则可以将其留空，并且在运行时通过入口起点文件中的 __webpack_public_path__ 动态设置。

__webpack_public_path__ = myRuntimePublicPath;

// 应用程序入口的其余部分
```

### 3.loader

loader用于处理除JavaScript和json文件以外的其他文件，并将它们转化为有效的模块以供应用程序使用，并添加到依赖图中。

```js
//webpack.config.js
/*
在webpack的配置中，loader有两个属性：
1.test：识别哪些文件会被loader转换
2.use：在进行转换时使用哪个loader
*/
const path = require('path');
module.exports = {
  output: {
    filename: '',//打包后的文件名
  },
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],//以txt结尾的文件用，raw-loader转换
  },
};
```

### 4.插件

loader用于转换某些类型的模块，插件用于执行范围更广的任务，例如：打包优化，资源管理，注入环境变量。

```js
//webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 用于访问内置插件
module.exports = {
  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],
};
```

### 5.模式

设置mode参数，可以启用webpack内置在相应环境下的优化

```js
//webpack.config.js
module.exports = {
  mode: 'production',//可以选择‘development’，‘production ’，‘none ’，默认值是‘production’
};
```

## 2.指南

### 1.起步

```js
//基本安装
mkdir webpack-demo
cd webpack-demo
npm init -y
npm install webpack webpack-cli --save-dev
//根目录创建文件夹
index.html
src/index.js
```

```js
//src/index.js
function component() {
  const element = document.createElement('div');
 // lodash（目前通过一个 script 引入）对于执行这一行是必需的
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  return element;
}
document.body.appendChild(component());
```

```html
<!--index.html-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>起步</title>
    <script src="https://unpkg.com/lodash@4.17.20"></script>
  </head>
  <body>
    <script src="./src/index.js"></script>
  </body>
</html>
```

我们还需要调整 `package.json` 文件，以便确保我们安装包是 `private(私有的)`，并且移除 `main` 入口。这可以防止意外发布你的代码

```js
//package.json
 {
   "name": "webpack-demo",
   "version": "1.0.0",
   "description": "",
  "private": true,
   "scripts": {
     "test": "echo \"Error: no test specified\" && exit 1"
   },
   "keywords": [],
   "author": "",
   "license": "MIT",
   "devDependencies": {
     "webpack": "^5.38.1",
     "webpack-cli": "^4.7.2",
   }
 }
```

创建一个bundle，先修改目录结构

```js
dist/index.html
删除index.html
//目前是手动创建dist文件夹，后期会自动生成该文件
//安装lodash
npm install --save lodash
//在安装一个 package，而此 package 要打包到生产环境 bundle 中时，你应该使用 npm install --save。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用 npm install --save-dev
```

引入lodash

```js
import _ from 'lodash';
 function component() {
   const element = document.createElement('div');
  // lodash 在当前 script 中使用 import 引入
   element.innerHTML = _.join(['Hello', 'webpack'], ' ');
   return element;
 }
 document.body.appendChild(component());
```

手动修改dist/index.html文件（后期会自动修改）

```html
<!--dist/index.html--> 
<!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <title>起步</title>
   </head>
   <body>
    <script src="main.js"></script>
       <!--打包后的文件-->
   </body>
 </html>
```

运行npx webpack进行打包，打开dist里的index.html可以看到‘hello webpack’。

使用一个配置文件

```js
//在根目录创建webpack.config.js文件
//webpack.config.js
const path = require('path');
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
  },
};
```

执行npx webpack --config webpack.config.js

一个快捷的打包方式：

修改package.json中scripts为：

```js
"scripts": {
    //..
    "build": "webpack"
   },
可以用npm run build来进行打包操作
```

### 2.资源管理

#### 1.css资源管理

为了在javascript模块中import一个css文件，需要安装style-loader和css-loader，并在module中配置这些loader。

```js
npm install --save-dev style-loader css-loader
//配置webpack.config.js文件
 const path = require('path');

 module.exports = {
   entry: './src/index.js',
   output: {
     filename: 'bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],//顺序不能变
      },
    ],
  },
 };
```

新建文件夹src/style.css

```css
src/style.css
.hello{
    color:red;
}
```

```js
src/index.js
import _ from 'lodash';
import './style.css';
 function component() {
   const element = document.createElement('div');
   // Lodash, now imported by this script
   element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  element.classList.add('hello');
   return element;
 }
 document.body.appendChild(component());
```

不加loader打包会报错

#### 2.images图像资源管理

```js
//配置webpack.config.js文件
const path = require('path');
 module.exports = {
   entry: './src/index.js',
   output: {
     filename: 'bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
   module: {
     rules: [
       {
         test: /\.css$/i,
         use: ['style-loader', 'css-loader'],
       },
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },
     ],
   },
 };
```

配置完毕后，现在再import 图片，此图片将被处理并添加到output目录，并且图片变量将包含该图片在处理后的最终url

```js
src/index.js
import _ from 'lodash';
 import './style.css';
import Icon from './icon.png';
 function component() {
   const element = document.createElement('div');

   // Lodash, now imported by this script
   element.innerHTML = _.join(['Hello', 'webpack'], ' ');
   element.classList.add('hello');

  // 将图像添加到我们已经存在的 div 中。
  const myIcon = new Image();
  myIcon.src = Icon;

  element.appendChild(myIcon);

   return element;
 }

 document.body.appendChild(component());
```

#### 3.字体资源管理

```js
//配置webpack.config.js文件
 const path = require('path');

 module.exports = {
   entry: './src/index.js',
   output: {
     filename: 'bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
   module: {
     rules: [
       {
         test: /\.css$/i,
         use: ['style-loader', 'css-loader'],
       },
       {
         test: /\.(png|svg|jpg|jpeg|gif)$/i,
         type: 'asset/resource',
       },
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
      },
     ],
   },
 };
```

#### 4.数据资源管理

想要导入CSV、TSV 和 XML，可以使用csv-loader和xml-loader来处理这三类文件

```js
npm install --save-dev csv-loader xml-loader
//webpack.config.js
 const path = require('path');
 module.exports = {
   entry: './src/index.js',
   output: {
     filename: 'bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
   module: {
     rules: [
       {
         test: /\.css$/i,
         use: ['style-loader', 'css-loader'],
       },
       {
         test: /\.(png|svg|jpg|jpeg|gif)$/i,
         type: 'asset/resource',
       },
       {
         test: /\.(woff|woff2|eot|ttf|otf)$/i,
         type: 'asset/resource',
       },
      {
        test: /\.(csv|tsv)$/i,
        use: ['csv-loader'],
      },
      {
        test: /\.xml$/i,
        use: ['xml-loader'],
      },
     ],
   },
 };
```

#### 5.自定义json模块parser

通过使用自定义parser代替特定的webpack loader，可将任何的toml、yaml或json5作为json模块导入

```js
//安装toml、yamljs、json5的packages：
npm install toml yamljs json5 --save-dev
//webpack.config.js配置
const path = require('path');
const toml = require('toml');
const yaml = require('yamljs');
const json5 = require('json5');

 module.exports = {
   entry: './src/index.js',
   output: {
     filename: 'bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
   module: {
     rules: [
       {
         test: /\.css$/i,
         use: ['style-loader', 'css-loader'],
       },
       {
         test: /\.(png|svg|jpg|jpeg|gif)$/i,
         type: 'asset/resource',
       },
       {
         test: /\.(woff|woff2|eot|ttf|otf)$/i,
         type: 'asset/resource',
       },
       {
         test: /\.(csv|tsv)$/i,
         use: ['csv-loader'],
       },
       {
         test: /\.xml$/i,
         use: ['xml-loader'],
       },
      {
        test: /\.toml$/i,
        type: 'json',
        parser: {
          parse: toml.parse,
        },
      },
      {
        test: /\.yaml$/i,
        type: 'json',
        parser: {
          parse: yaml.parse,
        },
      },
      {
        test: /\.json5$/i,
        type: 'json',
        parser: {
          parse: json5.parse,
        },
      },
     ],
   },
 };
```

### 3.输出管理



# 十三.gulp

------

# EndOne.js技術收集

## 1.cookie相关操作

### 1）.获取cookie

```js
cost getCookie=(name)=>{
    var arr,reg=new RegExp('(^| )'+name+'=([^;]*)(;|$)')
    if((arr=document.cookie.match(reg))) return unescape(arr[2])
    else return null
}
```

### 2）.设置cookie

```js
const setCookie=(name,value)=>{
    var Days=30
    var exp=new Date()
    exp.setTime(exp.getTime()+Days*60*1000)
    document.cookie=name+'='+escape(value)+';expires='+exp.toGMTString()+';path=/'
}
```

### 3）.删除cookie

```js
const delCookie=(name)=>{
    var timer=new Date(0).toGMTString()
    document.cookie=name+'=;expires='+timer+';path=/'
}
```

### 4）.读取cookie中的信息

```js
JSON.stringify(JSON.parse(decodeURIComponent(escape(window.atob(cookie.split('.')[1].replace(/-/g,'+').replace(/_/g,'/'))))))
```



## 2.rem自适应设置

新建utils文件夹，该文件夹下新建rem.js文件，文件内容如下:

```js
(function(document, window) {
    var dom= document.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function() {
					var clientWidth = dom.clientWidth;
                    if(!clientWidth) return;
                    if(clientWidth>=1920){
                        dom.style.fontSize = 100 * (clientWidth / 1920) + 'px';
                    }else if(clientWidth>=1680){
                        dom.style.fontSize = 100 * (clientWidth / 1680) + 'px';
                    }else if(clientWidth>=1440){
                        dom.style.fontSize = 100 * (clientWidth / 1440) + 'px';
                    }else if(clientWidth>=1280){
                        dom.style.fontSize = 100 * (clientWidth / 1280) + 'px';
                    }
                    else if(clientWidth>=1263){
                        dom.style.fontSize = 100 * (clientWidth / 1263) + 'px';
                    }else{
                        dom.style.fontSize = 100 * (clientWidth / 750) + 'px';
                    }
        };

    if(!document.addEventListener) return;
    win.addEventListener(resizeEvt, recalc, false);
    document.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);

```

用法：在main.js中引入rem.js，这里100 px=1 rem，记得设置vscode的默认值

## 3. .vscode文件配置

.vscode文件下，新建settings.json

```json
{
    "vetur.format.defaultFormatter.html": "prettyhtml",
    "vetur.format.defaultFormatterOptions": {
      "prettyhtml": {
        "printWidth": 100, // No line exceeds 100 characters
        "singleQuote": false // Prefer double quotes over single quotes
      }
    },
    "[scss]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "[css]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "[javascript]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "[json]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "[jsonc]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "editor.tabSize": 2, // tab大小为2空格
    "editor.formatOnSave": false, // 手动保存后自动格式化
    "files.autoSave": "off", // 取消文件自动保存
    "vetur.validation.template": false,
    "git.enableSmartCommit": true, // 关闭vetur对template区域的检测
    // vue 保存自动eslint 格式化
    "eslint.autoFixOnSave": true,
    // 让 prettier 使用 eslint 的代码格式进行校验
    "eslint.validate": [
      "javascript",
      "javascriptreact",
      "html",
      {
        "language": "html",
        "autoFix": true
      },
      {
        "language": "vue",
        "autoFix": true
      }
    ],
    // eslint自动格式化
    "editor.codeActionsOnSave": {
      "source.fixAll.eslint": true
    },
    "[vue]": {
      "editor.defaultFormatter": "octref.vetur"
    },
    "[html]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "window.zoomLevel": 0
  }
```

## 4.路由组件间跳转传参

```js
//在路由下添加下面类似代码
props:(route)=>({
    参数1:route.query.参数1
})
```

## 5.消除html标签

```js
val.replace(/<[^>*]/g,'')
```

## 6.md5加密

```js
1.npm install js-md5
2.import md5 from 'js-md5';
3.Vue.prototype.$md5 = md5;
4.this.$md5("加密内容")
```

## 7.点击复制

```js
toClipboard = () => {
    const copySpan = document.getElementById('copy');
    const range = document.createRange();

    range.selectNodeContents(copySpan);
    const selection = window.getSelection();
    selection.removeAllRanges();//（注意）
    selection.addRange(range);

    const copyContent = document.execCommand('Copy',false,null);
    selection.removeRange(range);

    if (copyContent) {

      console.log('复制成功', copyContent);

    }
  }
```

## 8.获取用户地理位置

```js
var x=document.getElementById("demo");
function getLocation()
{
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(showPosition,showError);
	}
	else
	{
		x.innerHTML="该浏览器不支持获取地理位置。";
	}
}

function showPosition(position)
{
	x.innerHTML="纬度: " + position.coords.latitude + 
	"<br>经度: " + position.coords.longitude;	
}
function showError(error)
{
    switch(error.code) 
    {
        case error.PERMISSION_DENIED:
            x.innerHTML="用户拒绝对获取地理位置的请求。"
            break;
        case error.POSITION_UNAVAILABLE:
            x.innerHTML="位置信息是不可用的。"
            break;
        case error.TIMEOUT:
            x.innerHTML="请求用户地理位置超时。"
            break;
        case error.UNKNOWN_ERROR:
            x.innerHTML="未知错误。"
            break;
    }
}
```

## 9.mock模拟接口测试

```js
//下载mock
npm install mockjs --save-dev
//在main.js同阶目录下创建mock.js文件夹
	// 引入mockjs
	const Mock = require('mockjs');
	// mock一组数据
	const produceNewsData = 123
	// Mock.mock( url, post/get , 返回的数据)；
	Mock.mock('/news/index', 'post', produceNewsData);
	Mock.mock('/news/index2', 'post', '789');
//在main.js下引入mock.js文件
require('./mock.js')
//接口应用
axios.post('/news/index').then((res) => {
      console.log(res);
    })
```

## 10.less引入

```
npm install less less-loader --save-dev
将less-loader的版本改为5.0.0
```

## 11.eslintrc配置

```js
//跟目录创建eslintrc.js文件
// https://eslint.org/docs/user-guide/configuring

module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint',
    "sourceType": "module",
  },
  env: {
    browser: true,
    "es6": true
  },
  // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention
  // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.
  extends: ['plugin:vue/essential', 'airbnb-base'],
  // required to lint *.vue files
  plugins: [
    'vue'
  ],
  // check if imports actually resolve
  settings: {
    'import/resolver': {
      webpack: {
        config: 'build/webpack.base.conf.js'
      }
    }
  },
  "globals": {
    "twaver": "readonly",
    "mono": "readonly"
  },
  // add your custom rules here
  rules: {
		'comma-dangle':'off',
    'linebreak-style': ["error", "unix"],
    // don't require .vue extension when importing
    'import/extensions': ['error', 'always', {
      js: 'never',
      vue: 'never'
    }],
    // disallow reassignment of function parameters
    // disallow parameter object manipulation except for specific exclusions
    'no-param-reassign': ['off', {
      props: true,
      ignorePropertyModificationsFor: [
        'state', // for vuex state
        'acc', // for reduce accumulators
        'e' // for e.returnvalue
      ]
    }],
    // allow optionalDependencies
    'import/no-extraneous-dependencies': ['error', {
      optionalDependencies: ['test/unit/index.js']
    }],
    'no-underscore-dangle': 0,
    'global-require': 0,
    "import/no-dynamic-require": 0,
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    "no-console": 0,
    "no-unused-vars": [
      "off",
      {
        "args": "none"
      }
    ],
    "no-mixed-operators": [
      "error",
      {
        "groups": [
          // ["+", "-", "*", "/", "%", "**"],
          // ["&", "|", "^", "~", "<<", ">>", ">>>"],
          // ["==", "!=", "===", "!==", ">", ">=", "<", "<="],
          ["&&", "||"],
          ["in", "instanceof"]
        ],
        "allowSamePrecedence": true
      }
    ]
  },

}
```

## 12.前端主题

```js
// variable.js
 
// 字体变量
const baseSize = {
  "--font-size-large-x": "22px",
  "--font-size-large": "18px",
  "--font-size-medium": "14px",
  "--font-size-medium-x": "16px",
  "--font-size-small-s": "10px",
  "--font-size-small": "12px",
};
 
//浅色
export const lightTheme = {
  "--fill-1": "#fff",
  "--text": "#3c3c3c",
  "--text-1": "#757575",
	"--text-2": "#222",
	"--bk":"url(@/assets/logo.png)",
  ...baseSize,
};
 
// 深色
export const darkTheme = {
  "--fill-1": "#222",
  "--text": "#fff",
  "--text-1": "rgba(255, 255, 255, 0.3)",
	"--text-2": "#ffcd32",
	"--bk":"none",
  ...baseSize,
};
```

```js
//样式用法
<style lang="scss">
 .text {
    display: inline-block;
    vertical-align: top;
    line-height: 70px;
    font-size: var(--font-size-large);
    color: var(--text-2);
  }
</style>	
```

```js
// theme.js切换主题
import { lightTheme, darkTheme } from "../src/assets/js/variable";
import cssVars from "css-vars-ponyfill";
export const initTheme = (theme) => {
  document.documentElement.setAttribute("data-theme", theme ? "light" : "dark");
  cssVars({
    watch: true, // 当添加，删除或修改其<link>或<style>元素的禁用或href属性时，ponyfill将自行调用
    variables: theme ? lightTheme : darkTheme, // variables 自定义属性名/值对的集合
    onlyLegacy: false, // false  默认将css变量编译为浏览器识别的css样式  true 当浏览器不支持css变量的时候将css变量编译为识别的css
  });
};
 
```

```js
//第二种方法
//less和scss图片插入方法
<style scoped lang="less">
@imgurl: "./images/";
.container {
  width: 100%;
  height: 100%;
  background: url("@{imgurl}background.jpg") no-repeat center;
  background-size: cover;
}
</style>
<style scoped lang="scss">
$imgPath: "../../../../assets/images/";
.plusIcon {
    display: inline-block;
    width: 14px;
    height: 14px;
    background: url(#{$imgPath}plus.svg) no-repeat center;
    margin-right: 9px;
  }
</style>
//1.设置主题
document.documentElement.setAttribute('data-theme',主题)
//scss判断
#theme.scss文件
@import './variable.scss'
@mixin color_primary($color){
    color:$color;
    [data-theme='主题']&{
        color:$color-primary-brown
    }
}
#variable.scss
$color-primary-brown:red;
$color-primary:blue;
#default
@import './theme.scss'
@import './variable.scss'
.left{
    @include color_primary($color-primary)
}
//在main.js中调用default.scss
```



## 13.中英文切换

```js
//下载依赖
npm install vue-i18n --save-dev
//在src/components下新建文件夹language，并在文件夹language下新建zh.js及en.js
【src/components/language/zh.js】
module.exports = {
    language: {
        name: 'English'
    },
    user: {
        login:'登录',
        register:'注册',
        loginUsername:'请输入邮箱/手机号',
    }
}

【src/components/language/en.js】
module.exports = {
    language: {
        name: '中文'
    },
    user: {
        login:'login',
        register:'register',
        loginUsername:'please input email or phone',
    }
}
//在main.js下引入及注册vue-i18n
//中英文切换
import VueI18n from 'vue-i18n'
Vue.use(VueI18n)
const i18n=new VueI18n({
    locale:localStorage.getItem('languageSet')||'zh',   //从localStorage里获取用户中英文选择，没有则默认中文
    messages:{
        'zh':require('./components/language/zh'),
        'en':require('./components/language/en')
    }
})

new Vue({
    el: '#app',
    router,
    i18n,   //把 i18n 挂载到 vue 根实例上
    components: {
        App
    },
    render: h => h(App),
})
//在dom里使用 $t(' ')，若在js里使用则 this.$t(' ')
<template>
    <span>{{$t('user.login')}}</span>   //登录
    <input type="text" :placeholder="$t('user.loginUsername')"  v-model="username" />   //输入用户名

    <div @click="changeLanguage()">{{$t('language.name')}}</div>   //切换中英文的按钮
</template>

<script>
    methods:{
        changeLanguage(){
            this.$i18n.locale=='zh'?this.$i18n.locale='en':this.$i18n.locale='zh'   //设置中英文模式
            localStorage.setItem('languageSet',this.$i18n.locale)   //将用户设置存储到localStorage以便用户下次打开时使用此设置
        },
        remind(){
            this.$toast(this.$t('user.loginUsername'))
        }
    }
<script>
```

## 14.设置跨域浏览器

1.在电脑上新建一个目录，例如：C:\MyChromeDevUserData

2.在属性页面中的目标输入框里加上   --disable-web-security --user-data-dir=C:\MyChromeDevUserData，--user-data-dir的值就是刚才新建的目录

## 15.node.js环境配置

https://blog.csdn.net/snsHL9db69ccu1aIKl9r/article/details/110507586

## 16.MonacoEditor（代码编辑器）

```js
npm install monaco-editor -S
npm install monaco-editor-webpack-plugin -S
//vue.config.js
const MonacoWebpackPlugin = require('monaco-editor-webpack-plugin')

module.exports = {
  //...
  //...
  configureWebpack: {
    plugins: [
      new MonacoWebpackPlugin()
    ]
  }
}

//封裝MonacoEditor.vue
<template>
  <div class="monaco-container">
    <div ref="container" class="monaco-editor"></div>
  </div>
</template>
import * as monaco from 'monaco-editor'
  props: {
	// 编辑器中呈现的内容
    codes: {
      type: String,
      default: function () {
        return ''
      }
    },
    readOnly: {
      type: Boolean,
      default: function () {
        return false
      }
    },
    // 主要配置
    editorOptions: {
      type: Object,
      default: function () {
        return {
          selectOnLineNumbers: true,
          roundedSelection: false,
          readOnly: this.readOnly, // 只读
          cursorStyle: 'line', // 光标样式
          automaticLayout: false, // 自动布局
          glyphMargin: true, // 字形边缘
          useTabStops: false,
          fontSize: 28, // 字体大小
          autoIndent: false // 自动布局
        }
      }
    }
  }
mounted () {
	this.monacoEditor = monaco.editor.create(this.$refs.container, {
	  value: this.codes, // 见props
	  language: 'python',
	  theme: 'vs-dark', // 编辑器主题：vs, hc-black, or vs-dark，更多选择详见官网
	  editorOptions: this.editorOptions // 同codes
	})
}
//新建一个install.js
import Monaco from 'path / of / your / MonacoEditor.vue' // 这里导入文件名不带后缀亦可

export default {
  install: function (Vue, options) {
    Vue.component('monaco', Monaco)
  }
}
//main.js
import componentsInstall from 'path / of / your /install.js'
Vue.use(componentsInstall)
//父组件调用
	 <monaco
	   :codes="content"
	   :readOnly="false"
	  >
	 </monaco>
//改进
<!-- 父组件 -->
<monaco
  :codes="content"
  :current="current"
>
</monaco>

// MonacoEditor.vue

//..
props: {
  //...
  //...
  current: Object // 类型随意，需要保证不同个组件编辑器切换时current值变化
}
//..
//..
watch: {
  current () {
    this.monacoEditor.setValue(this.codes)
  }
},
  mounted () {
    // ...
    this.monacoEditor.onDidChangeModelContent((event) => {
      let changeContent = this.monacoEditor.getValue()
      this.$emit('update:contentBody', changeContent)
    })
  },

```

## 17.vscode代码注释

下载korofileheader插件

设置里面找到 Custom Made 写入以下配置 ：

```js
"fileheader.customMade": {
    "FilePath": "",
    "Version": "2.0",
    "LastEditors": "lhl",
    "LastEditTime": "",
    "Description": "",
  }
```

ctrl+alt+i

ctrl+shift+p

## 18.vue-cli3代碼混淆打包

```js
cnpm i --save uglifyjs-webpack-plugin
//創建vue.config.js
#vue.config.js
const UglifyPlugin = require('uglifyjs-webpack-plugin')
module.exports = {
  configureWebpack: (config) => {
    if (process.env.NODE_ENV == 'production') {
      // 为生产环境修改配置
      config.mode = 'production'
      // 将每个依赖包打包成单独的js文件
      let optimization = {
        minimizer: [new UglifyPlugin({
            uglifyOptions: {
                warnings: false,
                compress: {
                  drop_console: true, 
                  drop_debugger: false,
                  pure_funcs: ['console.log'] 
                }
            }
         })]
      }
      Object.assign(config, {
        optimization
      })
    } else {
      // 为开发环境修改配置
      config.mode = 'development'
    }
  }
};
```

------

# EndTwo.css技术收集

## 1.<meta>标签

```html
//为搜索引擎定义关键词
<meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript">
//为网页定义描述内容
<meta name="description" content="免费 Web & 编程 教程">
//定义网页作者
<meta name="author" content="Runoob">
//每30秒刷新当前页面
<meta http-equiv="refresh" content="30">
```

## 2.滚轴样式

```css
::-webkit-scrollbar {
  width: 8px;
  height: 1px;
}
::-webkit-scrollbar-thumb {
  border-radius: 8px;
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
}
::-webkit-scrollbar-track {
  border-radius: 10px;
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
  background: #ededed;
}
```

------

# EndThree.学习网址收集

# 1.jquery在线手册

http://hemin.cn/jq/addClass.html

# 2.ant-design-vue按需引入

https://www.jianshu.com/p/b661e6850012

# 3.es6教程

https://es6.ruanyifeng.com/#docs/destructuring

# 4.element-plus

https://element-plus.gitee.io/#/zh-CN/component/layout

# 5.ant-design-vue

https://www.antdv.com/components/button-cn/

# 6.vant

https://youzan.github.io/vant/#/zh-CN/divider

# 7.iview

http://iview.talkingdata.com/#/components/input

# 8.vuetify

https://vuetifyjs.com/zh-Hans/

# 9.c3/h5超厉害动画效果网址

https://www.html5tricks.com/

# 10.超厉害的前端学习网址

https://docschina.org/

# 11.lodash

https://www.lodashjs.com/docs/lodash.chunk

# 12.ProseMirror富文本框文档

https://prosemirror.net/docs/guide/#intro

